# Complexity file

```{r}
# libraries

#library(packageCHT) BRANCHEMENT : DEVRA MARCHER UNE FOIS QUE LE PACKAGE SERA COMPLET
library(ggplot2)
```
Petit comme la team pour vous expliquez comment est-ce que j'ai fait : en gros la structure par algo c'est 
1) complexité théorique 
 - regarder le nombre de fois qu'une boucle while est lancé dans le pire des cas ...
2) complexité empirique 
 - lancer plusieurs fois l'algo avec des valeurs de n différentes.  Dans le fichier GS_bucket_complexity_test_function.R il y aun exemple il suffit de modifier une ligne pour avoir une fonction qui prend en argument n et qui renvoie le tmeps que met l'algo à tourner.
 - plot en normal (vs n^2)
 - plot avec une echelle logarithmique
3) R vs C++
 - J'ai un semblant de code qui devrait fonctionner mais à voir si il marche vrm 

## Gale-Shapley

### Complexité théorique

Nous allons calculer théoriquement la complexité de l'algorithme de Gale-Shapley présent dans le ficher GaleShapley.R.

Tout d'abord, notons les complexité au sein des boucles. Notons $n$ le nombre d'homme (= nombre de femme aussi).

```{r}
gale_shapley <- function(men_prefs, women_prefs) {
  free_men <- names(men_prefs)    #O(1)
  engaged <- list()    #O(1)
  next_proposal <- setNames(rep(1, length(free_men)), free_men)    #O(1)

  # Helper function: rank of a man for a woman
  rank <- lapply(women_prefs, function(prefs) setNames(seq_along(prefs), prefs))    #O(n^2) n vector of size n

  while (length(free_men) > 0) {
    man <- free_men[1]    #O(1)
    woman <- men_prefs[[man]][next_proposal[man]]    #O(1)

    # Man proposes
    if (is.null(engaged[[woman]])) {    #O(1)
      engaged[[woman]] <- man    #O(1)
      free_men <- setdiff(free_men, man)    #O(n) worst case
    } else {    #O(1)
      current <- engaged[[woman]]    #O(1)
      if (rank[[woman]][[man]] < rank[[woman]][[current]]) {    #O(1)
        engaged[[woman]] <- man    #O(1)
        free_men <- c(free_men, current)    #O(1)
        free_men <- setdiff(free_men, man)    #O(n) worst case
      } else {    #O(1)
        # Woman rejects this man
      }
    }

    next_proposal[man] <- next_proposal[man] + 1    #O(1)
  }

  matches <- data.frame(    #O(1)
    Man = unlist(engaged),
    Woman = names(engaged),
    stringsAsFactors = FALSE
  )
  return(matches)    #O(1)
}
```

Concernant la boucle while, chaque homme fait sa demande aux femmes dans l'ordre de ses préférences et il ne peut faire sa demande qu'une seule fois.

Nous avons dans le pire des cas $n$ propositions par homme. Vu qu'il y a $n$ homme, cela ferait $n^2$ demandes. Il faut aussi prendre en compte le fait que setdiff() à une complexité linéaire sur la liste prise en argument. Sauf que dans ce cas de figure précis, la liste que setdiff prend en argument (free_men) se retrouverait quasiment vide presque tout le temps. On peut donc négliger sa complexité.

Ainsi :
$$C(\text{Gale-Shapley})=O(n^2)$$
### Complexité empirique

Voyons comment évolue le temps que met l'algorithme à tourner en fonction de $n$.



```{r}
# A SUPPRIMER QUAND LES BRANCHEMENTS SERONT BIEN ORGANISÉS

#' Test the runtime of Gale-Shapley
#'
#' @description Runs the algorithm for random preference lists of size n and returns execution time.
#' @param n Number of men/women.
#' @return Execution time in seconds.
#' @export
test_gs_time <- function(n) {
  men <- paste0("M", 1:n)
  women <- paste0("W", 1:n)

  men_prefs <- lapply(1:n, function(i) sample(women))
  names(men_prefs) <- men

  women_prefs <- lapply(1:n, function(i) sample(men))
  names(women_prefs) <- women

  time <- system.time({
    gale_shapley(men_prefs, women_prefs)
  })
  return(time["elapsed"])
}
```

```{r}
# Choose sizes to test
sizes <- seq(500, 5000, by = 500)

# Measure runtime for each size
times <- sapply(sizes, test_gs_time)

```

```{r}

# Build data frame for plotting
df <- data.frame(
  n = sizes,
  time = times,
  n_squared = (sizes^2) / max(sizes^2) * max(times) # scaled for comparison
)

# Plot measured time and n^2 curve
ggplot(df, aes(x = n)) +
  geom_line(aes(y = time), size = 1.2, color = 'red') +
  geom_point(aes(y = time), size = 2, color = 'red') +
  geom_line(aes(y = n_squared), linetype = "dashed", size = 1, color = 'green') +
  labs(
    title = "Temporal Complexity of Gale–Shapley (Empirical vs n²)",
    x = "n (number of men/women)",
    y = "Execution time (seconds)"
  ) +
  theme_minimal(base_size = 14)
```
On observe bien un temps d'execution quadratique, car si l'on plot avec une échelle logarithmique on observe bien une droite de pente égale à 2.

```{r}
ggplot(df, aes(x = n)) +
  geom_line(aes(y = time), size = 1.2, color = 'red') +
  geom_point(aes(y = time), size = 2, color = 'red') +
  geom_line(aes(y = n_squared), linetype = "dashed", size = 1, color = 'green') +
  labs(
    title = "Gale–Shapley Complexity (Log–Log Scale)",
    x = "log(n)",
    y = "log(time)"
  ) +
  scale_x_log10() +
  scale_y_log10() +
  theme_minimal(base_size = 14)
```

## Gale-Shapley with buckets

### Theoritical Complexity

Partie à faire quand on aura la fonction finale 
```{r}
best_gs_bucket <- function(men_prefs, women_prefs) {
  men_names   <- names(men_prefs)
  women_names <- names(women_prefs)
  n <- length(men_prefs)
  men_index   <- setNames(seq_len(n), men_names)
  women_index <- setNames(seq_len(n), women_names)
  men_pref_num <- vector("list", n)
  for (h in seq_len(n)) {
    men_pref_num[[h]] <- women_index[ men_prefs[[h]] ]
  }
  women_pref_num <- vector("list", n)
  for (f in seq_len(n)) {
    women_pref_num[[f]] <- men_index[ women_prefs[[f]] ]
  }
  women_rank <- vector("list", n)
  for (f in seq_len(n)) {
    pref <- women_pref_num[[f]]
    r <- integer(n)
    for (pos in seq_len(n)) {
      r[ pref[pos] ] <- pos
    }
    women_rank[[f]] <- r
  }
  next_choice <- rep(1L, n)
  matching    <- rep(NA_integer_, n)

  # buckets[[k]] contient des couples (h,f) où k = priorité = next_choice[h]
  buckets <- vector("list", n)

  for (h in seq_len(n)) {
    f <- men_pref_num[[h]][1]
    buckets[[1]] <- append(buckets[[1]], list(c(h, f)))
  }
  while (TRUE) {
    p <- match(TRUE, lengths(buckets) > 0)
    if (is.na(p)) break
    prop <- buckets[[p]][[1]]
    buckets[[p]] <- buckets[[p]][-1]

    h <- prop[1]
    f <- prop[2]
    current <- match(f, matching)

    if (is.na(current)) {

      matching[h] <- f

    } else {
      rc <- women_rank[[f]][current]
      rn <- women_rank[[f]][h]

      if (rn < rc) {
        matching[h]      <- f
        matching[current] <- NA_integer_

        next_choice[current] <- nc <- next_choice[current] + 1L
        if (nc <= n) {
          f2 <- men_pref_num[[current]][nc]
          buckets[[nc]] <- append(buckets[[nc]], list(c(current, f2)))
        }

      } else {
        next_choice[h] <- nh <- next_choice[h] + 1L
        if (nh <= n) {
          f2 <- men_pref_num[[h]][nh]
          buckets[[nh]] <- append(buckets[[nh]], list(c(h, f2)))
        }
      }
    }
  }
  data.frame(
    Man   = men_names,
    Woman = women_names[matching],
    stringsAsFactors = FALSE
  )
}
```

### Empirical complexity

```{r}
# A SUPPRIMER QUAND LES BRANCHEMENT AURONT ETE FAIT

test_gs_bucket_time <- function(n) {
  men <- paste0("M", 1:n)
  women <- paste0("W", 1:n)

  men_prefs <- lapply(1:n, function(i) sample(women))
  names(men_prefs) <- men

  women_prefs <- lapply(1:n, function(i) sample(men))
  names(women_prefs) <- women

  time <- system.time({
    best_gs_bucket(men_prefs, women_prefs)
  })
  return(time["elapsed"])
}
```

```{r}
# Choose sizes to test
sizes <- seq(500, 5000, by = 500)
# Measure runtime for each size
times <- sapply(sizes, test_gs_bucket_time)

```

```{r}
# Build data frame for plotting
df <- data.frame(
  n = sizes,
  time = times,
  n_squared = (sizes^2) / max(sizes^2) * max(times),          # scaled n²
  n_cubed  = (sizes^3) / max(sizes^3) * max(times),
  n_log_n  = (sizes * log(sizes)) / max(sizes * log(sizes)) * max(times)  # scaled n log n
)
```

```{r}
# Plot measured time and n^2, n^3 curve
ggplot(df, aes(x = n)) +
  geom_line(aes(y = time), size = 1.2, color = 'red') +
  geom_point(aes(y = time), size = 2, color = 'red') +
  geom_line(aes(y = n_squared), linetype = "dashed", size = 1, color = 'green') +
  geom_line(aes(y = n_cubed), linetype = "dotdash", size = 1, color = 'blue') +
  labs(
    title = "Time Complexity of Gale–Shapley bucket (Empirical vs n^2 & n^3)",
    x = "n (number of men/women)",
    y = "Execution time (seconds)"
  ) +
  theme_minimal(base_size = 14)
```



```{r}
ggplot(df, aes(x = n)) +
  geom_line(aes(y = time), size = 1.2, color = 'red') +
  geom_point(aes(y = time), size = 2, color = 'red') +
  geom_line(aes(y = n_squared), linetype = "dashed", size = 1, color = 'green') +
  geom_line(aes(y = n_cubed), linetype = "dotdash", size = 1, color = 'blue') +
  labs(
    title = "Gale–Shapley with bucket Complexity (Log–Log Scale)",
    x = "log(n)",
    y = "log(time)"
  ) +
  scale_x_log10() +
  scale_y_log10() +
  theme_minimal(base_size = 14)
```
### R vs C++

```{r}
## A ENLEVER QUAND TOUT SERA MERGE

bench_heap_cpp <- function(n) {
  men  <- paste0("M", 1:n)
  women <- paste0("W", 1:n)

  men_prefs <- lapply(1:n, function(i) sample(women))
  names(men_prefs) <- men

  women_prefs <- lapply(1:n, function(i) sample(men))
  names(women_prefs) <- women

  system.time({
    gale_shapley_heap_cpp(men_prefs, women_prefs)
  })["elapsed"]
}
```

```{r}
times_r   <- sapply(sizes, test_gs_bucket_time)
times_cpp <- sapply(sizes, bench_heap_cpp)

df <- data.frame(
  n = rep(sizes, 2),
  time = c(times_r, times_cpp),
  version = rep(c("R bucket", "C++ Heap"), each = length(sizes))
)
```

```{r}
ggplot(df, aes(x = n, y = time, color = version)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(
    title = "Gale–Shapley Bucket: R vs C++ Runtime Comparison",
    x = "Problem size (n)",
    y = "Elapsed time (seconds)"
  ) +
  theme_minimal(base_size = 14)
```

```{r}
ggplot(df, aes(x = n, y = time, color = version)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "Gale–Shapley Bucket: R vs C++ (Log–Log Scale)",
    x = "log(n)",
    y = "log(time)"
  ) +
  theme_minimal(base_size = 14)
```

